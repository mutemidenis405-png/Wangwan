// -------------------- Phase 1: Offline AI + Document Ingestion + Dynamic TTS --------------------
package com.monster.study.ai

import android.content.Context
import android.speech.tts.TextToSpeech
import java.util.*
import org.apache.pdfbox.pdmodel.PDDocument
import org.apache.pdfbox.text.PDFTextStripper
import kotlin.random.Random

// -------------------- Document Model --------------------
data class Document(
    val id: String,
    val title: String,
    val text: String
)

// -------------------- Text Normalization --------------------
object TextProcessor {
    private val stopWords = setOf("the","is","a","an","and","or","to","of","in","on","for","with","as","by","at")

    fun normalize(text: String): List<String> =
        text.lowercase(Locale.US)
            .replace(Regex("[^\\p{L}\\p{N}\\s]"), " ")
            .split(Regex("\\s+"))
            .filter { it.length > 2 && it !in stopWords }
}

// -------------------- PDF Loader --------------------
object PdfLoader {
    fun load(context: Context, asset: String, id: String): Document {
        val pdf = PDDocument.load(context.assets.open(asset))
        val text = PDFTextStripper().getText(pdf)
        pdf.close()
        return Document(id, asset, text)
    }
}

// -------------------- Offline AI Engine --------------------
class OfflineAI(private val docs: List<Document>, private val tts: TextToSpeech? = null) {

    private val invertedIndex = mutableMapOf<String, MutableSet<String>>()
    private val docTokens = mutableMapOf<String, List<String>>()
    private val docMap = docs.associateBy { it.id }

    init {
        docs.forEach { doc ->
            val tokens = TextProcessor.normalize(doc.text)
            docTokens[doc.id] = tokens
            tokens.toSet().forEach { token ->
                invertedIndex.getOrPut(token) { mutableSetOf() }.add(doc.id)
            }
        }
    }

    // -------------------- Ask a query --------------------
    fun ask(query: String): String {
        val queryTokens = TextProcessor.normalize(query)
        val scores = mutableMapOf<String, Int>()
        queryTokens.forEach { token ->
            invertedIndex[token]?.forEach { docId ->
                scores[docId] = (scores[docId] ?: 0) + 1
            }
        }
        val bestDocId = scores.maxByOrNull { it.value }?.key ?: return "No relevant information found."
        val responseText = docMap[bestDocId]?.text?.take(1000) ?: "No relevant information found."
        speak(responseText)
        return responseText
    }

    // -------------------- Speak with dynamic TTS --------------------
    private fun speak(text: String) {
        tts ?: return
        val pitch = Random.nextDouble(0.9, 1.2).toFloat()
        val rate = Random.nextDouble(0.9, 1.1).toFloat()
        tts.setPitch(pitch)
        tts.setSpeechRate(rate)
        tts.speak(text, TextToSpeech.QUEUE_FLUSH, null, null)
    }

    // -------------------- Optional: Get document text directly --------------------
    fun getDocumentText(id: String): String? = docMap[id]?.text
}

// -------------------- Document Repository --------------------
object DocumentRepository {
    private val docs = mutableListOf<Document>()
    private var aiInstance: OfflineAI? = null
    private var ttsInstance: TextToSpeech? = null

    // Initialize with documents and optional TTS
    fun initialize(context: Context, initialDocs: List<Document>, tts: TextToSpeech? = null) {
        docs.clear()
        docs.addAll(initialDocs)
        ttsInstance = tts
        aiInstance = OfflineAI(docs, ttsInstance)
    }

    // Add a new document and rebuild AI
    fun addDocument(doc: Document) {
        docs.add(doc)
        aiInstance = OfflineAI(docs, ttsInstance)
    }

    fun getAI(): OfflineAI? = aiInstance
    fun getAllDocs(): List<Document> = docs.toList()

    // Load a PDF asset and add to repository
    fun loadPdf(context: Context, asset: String, id: String) {
        val doc = PdfLoader.load(context, asset, id)
        addDocument(doc)
    }
}
// -------------------- Phase 2: Flashcards, Cloze, MCQ, Active Recall --------------------
package com.monster.study.revision

import com.monster.study.ai.DocumentRepository
import kotlin.random.Random
import android.speech.tts.TextToSpeech
import java.util.*

// -------------------- Flashcard Model --------------------
data class Flashcard(
    val id: String,
    val question: String,
    val answer: String,
    val category: String = "Uncategorized",
    var lastReviewed: Long = 0,
    var confidence: Int = 0 // 0 = unknown, higher = more confident
)

// -------------------- Flashcard Engine --------------------
object FlashcardEngine {

    private val flashcards = mutableListOf<Flashcard>()
    private const val CLOZE_BLANK = "____"
    private var tts: TextToSpeech? = null

    // Initialize TTS for reading flashcards
    fun setTTS(ttsInstance: TextToSpeech) {
        tts = ttsInstance
    }

    // -------------------- Generate flashcards from documents --------------------
    fun generateFromDocuments() {
        flashcards.clear()
        DocumentRepository.getAllDocs().forEach { doc ->
            val sentences = doc.text.split(Regex("\\.\\s+")).filter { it.length > 20 }
            sentences.forEachIndexed { index, s ->
                // Simple Cloze: remove a random word
                val words = s.split(" ")
                if (words.size < 5) return@forEachIndexed
                val i = Random.nextInt(words.size)
                val question = words.toMutableList().apply { this[i] = CLOZE_BLANK }.joinToString(" ")
                flashcards.add(Flashcard("${doc.id}_$index", question, words[i], doc.title))
            }
        }
    }

    // -------------------- Get next flashcard --------------------
    fun getNextFlashcard(): Flashcard? {
        if (flashcards.isEmpty()) return null
        // Prioritize low-confidence cards first
        val card = flashcards.minByOrNull { it.confidence }
        card?.lastReviewed = System.currentTimeMillis()
        card?.let { speakQuestion(it) }
        return card
    }

    // -------------------- Mark flashcard result --------------------
    fun markFlashcard(id: String, correct: Boolean) {
        flashcards.find { it.id == id }?.apply {
            confidence = if (correct) confidence + 1 else maxOf(confidence - 1, 0)
            lastReviewed = System.currentTimeMillis()
        }
    }

    // -------------------- Generate MCQ --------------------
    fun generateMCQ(flashcard: Flashcard, options: Int = 4): Pair<String, List<String>> {
        val correct = flashcard.answer
        val distractors = mutableSetOf<String>()
        val words = DocumentRepository.getAllDocs().flatMap { it.text.split(" ") }
            .filter { it.length > 2 && it != correct }
        while (distractors.size < options - 1 && words.isNotEmpty()) {
            distractors.add(words.random())
        }
        val allOptions = (distractors + correct).shuffled()
        speakQuestion(flashcard)
        return Pair(flashcard.question, allOptions)
    }

    // -------------------- Recap Mode --------------------
    fun recap(limit: Int = 5) {
        val recapText = DocumentRepository.getAllDocs()
            .flatMap { it.text.split(". ") }
            .take(limit)
            .joinToString(". ")
        speakText(recapText)
    }

    // -------------------- Random Cloze Review --------------------
    fun getRandomCloze(): Flashcard? = flashcards.randomOrNull()?.also { speakQuestion(it) }

    // -------------------- TTS Helpers --------------------
    private fun speakQuestion(card: Flashcard) {
        speakText(card.question)
    }

    private fun speakText(text: String) {
        tts ?: return
        val pitch = Random.nextDouble(0.9, 1.2).toFloat()
        val rate = Random.nextDouble(0.9, 1.1).toFloat()
        tts.setPitch(pitch)
        tts.setSpeechRate(rate)
        tts.speak(text, TextToSpeech.QUEUE_FLUSH, null, null)
    }

    // -------------------- Get all flashcards --------------------
    fun getAllFlashcards(): List<Flashcard> = flashcards.toList()
}
// -------------------- Phase 3: Incremental Learning & Dynamic Updates --------------------
package com.monster.study.learning

import com.monster.study.ai.Document
import com.monster.study.ai.DocumentRepository
import com.monster.study.revision.FlashcardEngine
import com.monster.study.revision.Flashcard
import kotlin.random.Random

// -------------------- Incremental Learning Manager --------------------
object LearningManager {

    // -------------------- Add a single new document --------------------
    fun addDocument(doc: Document) {
        DocumentRepository.addDocument(doc)        // Update offline AI
        FlashcardEngine.generateFromDocuments()   // Refresh flashcards to include new content
    }

    // -------------------- Add multiple documents at once --------------------
    fun addDocuments(docs: List<Document>) {
        docs.forEach { DocumentRepository.addDocument(it) }
        FlashcardEngine.generateFromDocuments()
    }

    // -------------------- Track user queries for adaptive learning --------------------
    data class QueryLog(val query: String, val response: String, val timestamp: Long = System.currentTimeMillis())
    private val queryHistory = mutableListOf<QueryLog>()
    private const val MAX_HISTORY = 100

    fun logQuery(query: String, response: String) {
        queryHistory.add(QueryLog(query, response))
        if (queryHistory.size > MAX_HISTORY) queryHistory.removeAt(0)
    }

    // -------------------- Suggest documents relevant to past queries --------------------
    fun suggestRelevantDocuments(): List<Document> {
        if(queryHistory.isEmpty()) return emptyList()
        val recentTokens = queryHistory.takeLast(10).flatMap { it.query.split(" ") }
        return DocumentRepository.getAllDocs().filter { doc ->
            val docTokens = doc.text.split(" ")
            recentTokens.any { it in docTokens }
        }
    }

    // -------------------- Update flashcard confidence based on query history --------------------
    fun adaptFlashcardsBasedOnQueries() {
        val recentQueries = queryHistory.takeLast(20)
        recentQueries.forEach { q ->
            val flash = FlashcardEngine.getNextFlashcard()
            flash?.let {
                // If the user's query contains the answer, increase confidence
                if (q.query.contains(it.answer, ignoreCase = true)) {
                    FlashcardEngine.markFlashcard(it.id, true)
                }
            }
        }
    }

    // -------------------- Optional: Random review prompt --------------------
    fun promptRandomReview() {
        val card = FlashcardEngine.getRandomCloze()
        card?.let {
            // can integrate TTS reading or pop-up in UI
            println("Review Card: ${it.question} -> ${it.answer}")
        }
    }

    // -------------------- Clear query history --------------------
    fun clearHistory() {
        queryHistory.clear()
    }
}
// -------------------- Phase 4: Memory & Personalized Storage --------------------
package com.monster.study.memory

import android.content.Context
import com.monster.study.ai.DocumentRepository
import java.io.File
import org.json.JSONArray
import org.json.JSONObject

// -------------------- Memory Entry --------------------
data class MemoryEntry(
    val key: String,
    val value: String,
    val timestamp: Long = System.currentTimeMillis()
)

// -------------------- Memory Manager --------------------
object MemoryManager {

    private val memory = mutableListOf<MemoryEntry>()
    private const val FILE_NAME = "monster_memory.json"

    // -------------------- Load memory from local storage --------------------
    fun load(context: Context) {
        val file = File(context.filesDir, FILE_NAME)
        if (!file.exists()) return
        val array = JSONArray(file.readText())
        memory.clear()
        for (i in 0 until array.length()) {
            val obj = array.getJSONObject(i)
            memory.add(MemoryEntry(obj.getString("key"), obj.getString("value"), obj.getLong("timestamp")))
        }
    }

    // -------------------- Save memory to local storage --------------------
    fun save(context: Context) {
        val array = JSONArray()
        memory.forEach {
            val obj = JSONObject()
            obj.put("key", it.key)
            obj.put("value", it.value)
            obj.put("timestamp", it.timestamp)
            array.put(obj)
        }
        File(context.filesDir, FILE_NAME).writeText(array.toString())
    }

    // -------------------- Remember a new fact --------------------
    fun remember(context: Context, key: String, value: String) {
        memory.removeAll { it.key.equals(key, ignoreCase = true) } // overwrite if exists
        memory.add(MemoryEntry(key, value))
        save(context)
    }

    // -------------------- Recall a fact --------------------
    fun recall(key: String): String? {
        return memory.find { it.key.equals(key, ignoreCase = true) }?.value
    }

    // -------------------- Forget a fact --------------------
    fun forget(context: Context, key: String) {
        memory.removeAll { it.key.equals(key, ignoreCase = true) }
        save(context)
    }

    // -------------------- List all memory entries --------------------
    fun listAll(): List<MemoryEntry> = memory.toList()

    // -------------------- Optional: Search memory by keyword --------------------
    fun search(keyword: String): List<MemoryEntry> {
        return memory.filter { it.key.contains(keyword, ignoreCase = true) || it.value.contains(keyword, ignoreCase = true) }
    }
}
// -------------------- Phase 5: Online Wikipedia & Voice Search --------------------
package com.monster.study.online

import android.app.Activity
import android.content.Intent
import android.speech.RecognizerIntent
import android.speech.tts.TextToSpeech
import android.webkit.WebView
import android.webkit.WebViewClient
import android.widget.Toast
import kotlinx.coroutines.*
import org.json.JSONObject
import java.net.URL
import java.util.*

class OnlineAssistant(
    private val activity: Activity,
    private val tts: TextToSpeech,
    private val webView: WebView
) {

    companion object {
        const val VOICE_REQUEST_CODE = 1001
    }

    init {
        webView.settings.javaScriptEnabled = true
        webView.webViewClient = WebViewClient()
    }

    // -------------------- Launch voice recognition --------------------
    fun listenVoice() {
        val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
            putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
            putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.getDefault())
            putExtra(RecognizerIntent.EXTRA_PROMPT, "Speak your query to Monster")
        }
        activity.startActivityForResult(intent, VOICE_REQUEST_CODE)
    }

    // -------------------- Handle voice result --------------------
    fun handleVoiceResult(requestCode: Int, resultCode: Int, data: Intent?) {
        if (requestCode != VOICE_REQUEST_CODE || resultCode != Activity.RESULT_OK || data == null) return
        val results = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS)
        val query = results?.firstOrNull() ?: return
        searchWikipedia(query)
    }

    // -------------------- Search Wikipedia online --------------------
    fun searchWikipedia(query: String) {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                val apiUrl = "https://en.wikipedia.org/api/rest_v1/page/summary/${query.replace(" ", "_")}"
                val jsonStr = URL(apiUrl).readText()
                val json = JSONObject(jsonStr)
                val title = json.optString("title", "")
                val extract = json.optString("extract", "No summary found.")

                withContext(Dispatchers.Main) {
                    // Load summary into WebView
                    webView.loadData("<h3>$title</h3><p>$extract</p>", "text/html", "UTF-8")
                    // Speak summary
                    tts.speak(extract, TextToSpeech.QUEUE_FLUSH, null, null)
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(activity, "Wikipedia search failed.", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
}
// -------------------- Phase 6: Library & Classification System --------------------
package com.monster.study.library

import com.monster.study.ai.Document
import com.monster.study.ai.DocumentRepository

// -------------------- Library Document Model --------------------
data class LibraryDocument(
    val document: Document,
    val category: String,
    val tags: List<String> = emptyList()
)

// -------------------- Document Library --------------------
object DocumentLibrary {

    private val library = mutableListOf<LibraryDocument>()

    // -------------------- Initialize library from existing documents --------------------
    fun initialize() {
        library.clear()
        DocumentRepository.getAllDocs().forEach { doc ->
            library.add(LibraryDocument(doc, "Uncategorized"))
        }
    }

    // -------------------- Add a document with category and optional tags --------------------
    fun addDocument(doc: Document, category: String, tags: List<String> = emptyList()) {
        library.add(LibraryDocument(doc, category, tags))
        DocumentRepository.addDocument(doc) // keep offline AI updated
    }

    // -------------------- Get documents by category --------------------
    fun getByCategory(category: String): List<LibraryDocument> {
        return library.filter { it.category.equals(category, ignoreCase = true) }
    }

    // -------------------- Get documents by tag --------------------
    fun getByTag(tag: String): List<LibraryDocument> {
        return library.filter { it.tags.any { t -> t.equals(tag, ignoreCase = true) } }
    }

    // -------------------- Search documents in the library by keyword --------------------
    fun search(keyword: String): List<LibraryDocument> {
        return library.filter { 
            it.document.text.contains(keyword, ignoreCase = true) || 
            it.document.title.contains(keyword, ignoreCase = true) 
        }
    }

    // -------------------- List all categories --------------------
    fun listCategories(): List<String> {
        return library.map { it.category }.distinct()
    }

    // -------------------- List all tags --------------------
    fun listTags(): List<String> {
        return library.flatMap { it.tags }.distinct()
    }

    // -------------------- Remove a document --------------------
    fun removeDocument(doc: Document) {
        library.removeAll { it.document.id == doc.id }
        // Optionally, remove from offline AI as well (rebuild)
        DocumentRepository.addDocument(doc) // or adjust AI accordingly
    }
}
// -------------------- Phase 7: Unified WebView Dashboard --------------------
package com.monster.study.ui

import android.app.*
import android.content.*
import android.os.*
import android.speech.tts.TextToSpeech
import android.webkit.*
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.monster.study.ai.DocumentRepository
import com.monster.study.memory.MemoryManager
import com.monster.study.online.OnlineAssistant
import com.monster.study.revision.FlashcardEngine

class MonsterActivity : AppCompatActivity(), TextToSpeech.OnInitListener {

    private lateinit var webView: WebView
    private lateinit var tts: TextToSpeech
    private lateinit var onlineAssistant: OnlineAssistant

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // -------------------- Initialize TTS --------------------
        tts = Te
